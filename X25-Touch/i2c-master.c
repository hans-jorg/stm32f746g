/**
 * @file    i2c-master.c
 *
 * @brief   I2C implementation of a master interface for STM32F746
 *
 * @note    Simple implementation. Configured to use 16 MHz HSI as clock source
 *
 * @author  Hans
 */

#include "stm32f746xx.h"
#include "system_stm32f746.h"
#include "i2c-master.h"
#include "gpio.h"

/**
 *  @brief  Data structure to store information about I2C Configuration
 */
typedef struct {
    I2C_TypeDef             *i2c;
    GPIO_PinConfiguration   sclpin;
    GPIO_PinConfiguration   sdapin;
} I2C_Configuration_t;


/**
 *
 * @brief I2CCLK frequency 
 * 
 *
 * @note  I2CCLK Clock is configured in the RCC->DCKCFGR2 register.
 *        They are I2CxSEL fields, one for each I2C unit
 *  
 * @note  Clock sources
 * 
 *  | Source         | I2CxSEL |
 *  |----------------|---------|
 *  |  APB1 (PCLK1)  |   00    |
 *  |  SYSCLK        |   01    |
 *  |  HSI           |   10    |
 * 
 * @note Minimal frequencies
 * 
 * | Mode                | Analog filter |  DNF = 1 |
 * |---------------------|---------------|----------|
 * | Standard mode       |    2 MHz      |   2 MHz  |
 * | Fast mode           |   10 MHz      |   9 MHz  |
 * | Fast plus mode      |   22.5 MHz    |  16 MHz  |
 * 
 * OBS: Using HSI (=16 MHz) as filter, it is not possible to use Fast plus mode
 * 
 * @note  From Table 182 of the STM32F746NG Datasheet
 * 
 * | Parameter     |  Standard  |   Fast     | Fast Plus  |
 * |---------------|------------|------------|------------|
 * |  PRESC        |      3     |       1    |       0    |
 * |  SCLL         |     0x13   |     0x9    |     0x4    |
 * |  SCLH         |     0xF    |     0x3    |     0x2    |
 * |  SDADEL       |     0x2    |     0x2    |     0x0    |
 * |  SCLDEL       |     0x4    |     0x3    |     0x2    |
 */

/**
 * @brief   All timing for 16 MHz (=HSI)
 *
 * @note    Generated by STM3CubeMX for a 16 MHz I2CCLK
 * 
  * @note The timing is set by
 *       PRESC (31-28:4 bits):   fPRESC = fI2CCLK/(PRESC+1)
 *       SCLDEL(23-20:4 bits):   tSCLDEL= tPRESC*(SCLDEL+1)
 *       SDADEL(19-10:4 bits):   tSDADEL= tPRESC*(SDADEL+1)
 *       SCLH  (15-8:8 bits):    tSCLH = (SCLH+1)*tPRESC
 *       SCLL  ( 7-0:8 bits):    tSCLL = (SCLL+1)*tPRESC
 * 
 * @note The restrictions are:
 * 
 *       SDADEL >= (tfmax+tHDDATmin-tAFmin-(DNF+3)*tI2CCLK)/(PRESC+1)*tI2CCLK
 *       SDADEL <= (tHDDATmax-fAFmax-(DNF+4)xtI2CCLK)/(PRESC+1)*tI2CCLK
 *       SCLDEL >= (trmax+tSUDAT,om)/(PRESC+1)*tI2CCLK-1
 *
 * @note The I2C standard specifies the following parameters (RM Table 180)
 * 
 * | Speed    | fSCL | tHDSTA | tSUSTA | tSUSTO | tBUF | tLOW | tHIGH | tf  | tf  |
 * |----------|------|--------|--------|--------|------|------|-------|-----|-----|
 * | Standard |  100 |   4    |   4,7  |   4.0  |  4.7 |  4.7 |  4,0  | 1.0 | 0.3 |
 * | Fast     |  400 |   0.6  |   0.6  |   0.6  |  1.3 |  1.3 |  0.6  | 0.3 | 0.3 |
 * | Fast plus| 1000 |   0.26 |   0.26 |   0.26 |  0.5 |  0.5 |  0.26 | 0.12| 0.12|
 * 
 * @note The I2C standard specifies the following parameters (RM Table 178)
 * 
 * 
 *| Speed     |tHDDATmin|tVDDATmax|tSUDATmin|trmax |tfmax|
 *|-----------|---------|---------|---------|------|-----|
 *| Standard  |    0    |   3.45  |  0.250  |  1   | 0.3 |
 *| Fast      |    0    |   0.9   |  0.100  |  0.3 | 0.3 |
 *| Fast plus |    0    |   0.45  |  0.050  |  0.12| 0.12|
 *| SMBUS     |    0.3  |     -   |  0.250  |  1   | 0.3 |
 * 
 * @note tAF (Maximum pulse width of spikes that are suppressed by the analog
 *       filter) is defined in the STM32F746NG datasheet
 * 
 * | Parameter |  Min  |  Max  |
 * |-----------|-------|-------|
 * |  tAF (ns) |   50  |  150  |
 * 
 * @note Table with values for TIMINGR generated by STM32CubeMX
 *       tr and tf considered 0.
 * 
 * | Speed     |   None     |   Analog   | Digital=1  | Digital=2  |
 * |-----------|------------|------------|------------|------------|
 * |  100 KHz  | 0x00303D5D | 0x00303D5B | 0x00303C5C | 0x00303B5B |
 * |  400 KHz  | 0x0010071B | 0x0010061A | 0x0010061A | 0x00100519 |
 * | 1000 KHz  | 0x00000208 | 0x00000107 | 0x00000107 | 0x00000006 |
 * 
 * @note TIMINGR = 0x00303D5D means
 *                  PRESC=0   -> fPRESC = fI2CCLK/(PRESC+1)
 *                  SCLDEL=3
 *                  SDADEL=3
 *                  SCLH=3D   = 61
 *                  SCLL=5D   = 91
 *
 * @note Table 182 of RM shows another set of values for a 16 MHz clock.
 *       It is not clear which kind of filter is beeing used!
 * 
 * | Speed          | TIMINGR     | PRESC | SCLDEL | SDADEL | SCLH | SCLL |
 * |----------------|-------------|-------|--------|--------|------|------|
 * |      100 KHz   | 0x30420F13  |  0x3  |   0x4  |   0x2  | 0x0F | 0x13 | 
 * |      400 KHz   | 0x10320309  |  0x1  |   0x3  |   0x2  | 0x03 | 0x09 |
 * |     1000 KHz   | 0x00200204  |  0x0  |   0x2  |   0x0  | 0x02 | 0x04 |
 *   
 */

                                      
/**
 * @brief   Configuration for STM32F746G Discovery Boardd 
 * 
 * @note
 * 
 * |  I2C   |    SCL             |           SDA              |
 * |--------|--------------------|----------------------------|
 * |  I2C1  |  PB6 *PB8*         |  PB7 *PB9*                 |
 * |  I2C2  |  PB10 PF1 PH4      |  PB11 PF0 PH5              |
 * |  I2C3  |  PA8 *PH7*         |  PC9 *PH8*                 |
 * |  I2C4  |  PD12 PF14 PH11    |  PD13 PF15 PH12            |
 *
 * Only I2C1 and I2C3 in the table below
 * I2C1 at PB8 and PB9 used for EXT I2C (Arduino connectors)
 * I2C3 at PH7 and PH* used for LCD Touch and AUDIO I2C
 * Other I2C has pin usage conflicts
 *
 * @note All SCL and SDA pins must be configured as 
 *                     ALTERNATE FUNCTION (=4)
 *                     OPEN DRAIN
 *                     HIGH SPEED
 *                     PULL-UP
 */
static I2C_Configuration_t i2c_configuration[] = {
    //          SCL            SDA
    //      GPIO  Pin AF   GPIO  Pin AF
    { I2C1, 
            {GPIOB,  8, 4, 2, 1, 3, 1}, // SCL 
            {GPIOB,  9, 4, 2, 1, 3, 1}, // SDA
    },
    { I2C3, 
            {GPIOH,  7, 4, 2, 1, 3, 1}, // SCL
            {GPIOH,  8, 4, 2, 1, 3, 1}, // SDA
    },
    { 0,    
            {    0,  0, 0, 0, 0, 0, 0}, // SCL
            {    0,  0, 0, 0, 0, 0, 0}, // SDA
    }
};

/**
 * @brief  Interrupt routines and data structures for I2C
 * 
 */
///@{

#define I2C_OPERATION_WRITE             0
#define I2C_OPERATION_READ              1
#define I2C_OPERATION_WRITE_READ        2

typedef struct {
    unsigned char *pointer;
    int           operation;
    int           count;
    int           status;
} I2C_Info;

static I2C_Info     i2c1_info;  // Info for I2C1
static I2C_Info     i2c2_info;  // Info for I2C2
static I2C_Info     i2c3_info;  // Info for I2C3
static I2C_Info     i2c4_info;  // Info for I2C4

/**
 * @brief Process I2C Error Interrupts
 * 
 * @param i2c 
 * @param i2cinfo 
 */
void I2C_ProcessErrorInterrupt(I2C_TypeDef *i2c, I2C_Info *i2cinfo) {



}

/**
 * @brief Process I2C Event Interrupt
 * 
 * @param i2c 
 * @param i2cinfo 
 */
void I2C_ProcessEventInterrupt(I2C_TypeDef *i2c, I2C_Info *i2cinfo) {



}

/**
 * @brief I2C1 Event interrupt
 */
void I2C1_EV_IRQHandler(void) {

    I2C_ProcessEventInterrupt(I2C1,&i2c1_info);
}

/**
 * @brief I2C1 Error interrupt
 */
void I2C1_ER_IRQHandler(void) {

    I2C_ProcessErrorInterrupt(I2C1,&i2c1_info);
}

/**
 * @brief I2C2 Event interrupt
 */
void I2C2_EV_IRQHandler(void) {

    I2C_ProcessEventInterrupt(I2C2,&i2c2_info);
}

/**
 * @brief I2C2 Error interrupt
 */
void I2C2_ER_IRQHandler(void) {

    I2C_ProcessErrorInterrupt(I2C2,&i2c2_info);
}

/**
 * @brief I2C3 Event interrupt
 */
void I2C3_EV_IRQHandler(void) {

    I2C_ProcessEventInterrupt(I2C3,&i2c3_info);
}

/**
 * @brief I2C3 Error interrupt
 */
void I2C3_ER_IRQHandler(void) {

    I2C_ProcessErrorInterrupt(I2C3,&i2c3_info);
}

/**
 * @brief I2C4 Event interrupt
 */
void I2C4_EV_IRQHandler(void) {

    I2C_ProcessEventInterrupt(I2C4,&i2c4_info);
}

/**
 * @brief I2C1 Error interrupt
 */
void I2C4_ER_IRQHandler(void) {

    I2C_ProcessErrorInterrupt(I2C4,&i2c4_info);
}
///@}


/**
 *  @brief  ConfigurePins
 *
 *  @note   For now, uses GPIO library
 */
static int I2CMaster_ConfigurePins( I2C_TypeDef *i2c ) {
I2C_Configuration_t *p;

    // Lookup configuration information on table
    p = i2c_configuration;
    while( p->i2c && (i2c!=p->i2c) ) p++;

    // Not found!!
    if( ! p->i2c )
        return -1;

    // Pins not configurable
    if( (p->sclpin.gpio == 0) || (p->sdapin.gpio == 0) )
        return -2;
    // Configure pins when possible
    GPIO_ConfigureSinglePin(&(p->sclpin));
    GPIO_ConfigureSinglePin(&(p->sdapin));
}


/**
 *  @brief  I2CMaster_PeripheralClockEnable
 *
 *  @note   Using HSI as I2CCLK clock source (=16 MHz)
 */
static void
I2CMaster_PeripheralClockEnable( I2C_TypeDef *i2c ) {

    // Enable Peripheral Clock
    if ( i2c == I2C1 ) {
        RCC->APB1ENR |= RCC_APB1ENR_I2C1EN_Msk;
    } else if ( i2c == I2C2 ) {
        RCC->APB1ENR |= RCC_APB1ENR_I2C2EN_Msk;
    } else if ( i2c == I2C3 ) {
        RCC->APB1ENR |= RCC_APB1ENR_I2C3EN_Msk;
    } else if ( i2c == I2C4 ) {
        RCC->APB1ENR |= RCC_APB1ENR_I2C4EN_Msk;
    }

}

/**
 *  @brief  I2CMaster_PeripheralClockEnable
 *
 *  @note   Using HSI as I2CCLK clock source (=16 MHz)
 */
#define I2CLKSRC (2)


static void
I2CMaster_I2CClockEnable( I2C_TypeDef *i2c ) {

    // Enable I2C clocks
    if ( i2c == I2C1 ) {
        RCC->DCKCFGR2 =  (RCC->DCKCFGR2&~(3<<RCC_DCKCFGR2_I2C1SEL_Pos))
                        |(I2CLKSRC<<RCC_DCKCFGR2_I2C1SEL_Pos);
    } else if ( i2c == I2C2 ) {
        RCC->DCKCFGR2 =  (RCC->DCKCFGR2&~(3<<RCC_DCKCFGR2_I2C2SEL_Pos))
                        |(I2CLKSRC<<RCC_DCKCFGR2_I2C2SEL_Pos);
    } else if ( i2c == I2C3 ) {
        RCC->DCKCFGR2 =  (RCC->DCKCFGR2&~(3<<RCC_DCKCFGR2_I2C3SEL_Pos))
                        |(I2CLKSRC<<RCC_DCKCFGR2_I2C3SEL_Pos);
    } else if ( i2c == I2C4 ) {
        RCC->DCKCFGR2 =  (RCC->DCKCFGR2&~(3<<RCC_DCKCFGR2_I2C4SEL_Pos))
                        |(I2CLKSRC<<RCC_DCKCFGR2_I2C4SEL_Pos);
    }

}

/**
 *  @brief  I2CMaster_Reset
 *
 *  @note   Reset I2C using the SWRST pin on the APB1RSTR
 * 
 *  @note   There is another way to reset it by using the PE=0, PE=1 
 *          sequence as describe in RM 30.4.4: "A software reset can be 
 *          performed by clearing the PE bit in the I2C_CR1 register"
 * 
 */
static void I2CMaster_Reset( I2C_TypeDef *i2c ) {
uint32_t mask;

    if ( i2c == I2C1 ) {
        mask =  RCC_APB1RSTR_I2C1RST;
    } else if ( i2c == I2C2 ) {
        mask =  RCC_APB1RSTR_I2C2RST;
    } else if ( i2c == I2C3 ) {
        mask =  RCC_APB1RSTR_I2C3RST;
    } else if ( i2c == I2C4 ) {
        mask =  RCC_APB1RSTR_I2C4RST;
    }
    // Set reset pin
    RCC->APB1RSTR |=  mask;
    // Clear reset pin
    RCC->APB1RSTR &= ~mask;

}



/**
 *  @brief  I2CMaster_Disable
 *
 *  @note   Disable I2C and at the same time, reset it
 *          See RM 30.4.4 
 * 
 *  @note   When cleared, PE must be kept low for at
 *          least 3 APB clock cycles. (RM Section 30.7.1)
 * 
 *  @note   This is ensured by writing the following software sequence:
 *           - Write PE=0 
 *           - Check PE=0 
 *           - Write PE=0
 *          (RM Section 30.4.5)
 */
static void I2CMaster_Disable( I2C_TypeDef *i2c ) {
    
    // Turn off device (Three times, see Note in RM Section 30.7.1 */
    i2c->CR1 &= ~I2C_CR1_PE;
    i2c->CR1 &= ~I2C_CR1_PE;
    i2c->CR1 &= ~I2C_CR1_PE;
}

/**
 *  @brief  I2CMaster_Init
 *
 *  @note   Initializes I2C and configure it
 * 
 *  @note   It only accepts one of the filters: None, Analog or Digital.
 */
int
I2CMaster_Init( I2C_TypeDef *i2c, uint32_t conf, uint32_t timing) {
int index;

    // In the example in CubeF7, there is a 200 ms delay here

    // Enable peripheral clock to use registers
    I2CMaster_PeripheralClockEnable(i2c);

    // Disable I2C (It resets too)
    I2CMaster_Disable(i2c);

    // Configure pins
    I2CMaster_ConfigurePins(i2c);

    // Configure filters
    if( (conf&I2C_CONF_FILTER_NONE)!=0 ) {
        // Using no filter
        i2c->CR1 |= I2C_CR1_ANFOFF;                 // Turn off analog filter
        i2c->CR1 = (i2c->CR1&~(I2C_CR1_DNF_Msk));   // Turn off digital filter
        index = 0;
    } else if( (conf&I2C_CONF_FILTER_ANALOG)!=0 )  {
        // Using analog filter
        i2c->CR1 &= ~I2C_CR1_ANFOFF;                // Turn on analog filter
        i2c->CR1 = (i2c->CR1&~(I2C_CR1_DNF_Msk));   // Turn off digital filter
        index = 1;
    } else if( (conf&I2C_CONF_FILTER_DIGITAL_MASK)!=0 ) {
        i2c->CR1 |= I2C_CR1_ANFOFF;                 // Turn off analog filter
        // Using digital filter
        uint32_t dnf = (conf&I2C_CONF_FILTER_DIGITAL_MASK)>>I2C_CONF_FILTER_DIGITAL_Pos;
        // Limit dnf to 2
        if( dnf > 2 ) dnf = 2;
        i2c->CR1 = (i2c->CR1&~(I2C_CR1_DNF_Msk))|(dnf<<I2C_CR1_DNF_Pos);
    }

    i2c->TIMINGR = timing;


    // Turn Peripheral Clock for the I2C interface
    I2CMaster_I2CClockEnable(i2c);

    // Turn on device. Three times, just in case. See above */
    i2c->CR1 |= I2C_CR1_PE;
    i2c->CR1 |= I2C_CR1_PE;
    i2c->CR1 |= I2C_CR1_PE;

    return 0;
}

/**
 * @brief I2CMaster_Write
 * 
 * @note  Send the *n* bytes in the *data array* to slave *addr*
 * 
 * @param i2c 
 * @param address 
 * @param data 
 * @param n 
 * @return int 
 */
int
I2CMaster_Write( I2C_TypeDef *i2c, uint32_t addr, unsigned char *data, int nbytes) {
unsigned char *p = data;

    i2c->CR2 =   (i2c->CR2 & ~(
                     I2C_CR2_SADD_Msk
                    |I2C_CR2_NBYTES_Msk
                    |I2C_CR2_ADD10
                    |I2C_CR2_RD_WRN
                    |I2C_CR2_HEAD10R
                    |I2C_CR2_RELOAD
                    )
                 )
                |((addr<<I2C_CR2_SADD_Pos)&I2C_CR2_START_Msk)
                |((nbytes<<I2C_CR2_NBYTES_Pos)&I2C_CR2_NBYTES_Msk)
                |I2C_CR2_AUTOEND;
// Polling (for now)
    i2c->TXDR = *p++;
    i2c->CR2 |= I2C_CR2_START;
    while(1) {
        while( (i2c->ISR&I2C_ISR_TXIS) == 0 ) {}
        nbytes--;
        if( nbytes == 0 )
            break;
        i2c->TXDR = *p++;
    } 
    i2c->CR2 |= I2C_CR2_STOP;  // should be set before last byte ?
    return 0;
}

/**
 * @brief I2CMaster_Read
 * 
 * @note  Read *n* bytes into the *data array* from slave *addr*
 * 
 * @param i2c 
 * @param address 
 * @param data 
 * @param n 
 * @return int 
 */
int
I2CMaster_Read( I2C_TypeDef *i2c, uint32_t addr, unsigned char *data, int nbytes) {
unsigned char *p = data;

    i2c->CR2 =   (i2c->CR2 & ~(
                     I2C_CR2_SADD_Msk
                    |I2C_CR2_NBYTES_Msk
                    |I2C_CR2_ADD10
                    |I2C_CR2_HEAD10R
                    |I2C_CR2_RELOAD
                    )
                 )
                |((addr<<I2C_CR2_SADD_Pos)&I2C_CR2_START_Msk)
                |((nbytes<<I2C_CR2_NBYTES_Pos)&I2C_CR2_NBYTES_Msk)
                |I2C_CR2_AUTOEND
                |I2C_CR2_RD_WRN;
// Polling (for now)
    i2c->CR2 |= I2C_CR2_START;
    while(nbytes--) {
        while( (i2c->ISR&I2C_ISR_RXNE) == 0 ) {}
        *p++ = i2c->RXDR;
        nbytes--;
    } 

    return 0;
}

