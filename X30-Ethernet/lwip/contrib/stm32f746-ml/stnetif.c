/**
 * @file  ethernetif.c
 *
 * @note  Ethernet Interface for STM32F746 ETH
 *
 */

/*
 * TODO: Replace ethernetif by ethernetif
 */

#include <stdlib.h>
#include <string.h>
#include <stdarg.h>

#include "lwip/opt.h"
#include "lwip/def.h"
#include "lwip/mem.h"
#include "lwip/pbuf.h"
#include "lwip/stats.h"
#include "lwip/snmp.h"
#include "lwip/ethip6.h"
#include "lwip/etharp.h"
#include "netif/ppp/pppoe.h"

// Port to STM32F746xx
#include "eth.h"
#include "stnetif.h"

#include "debugmessages.h"
/**
 * @brief   verbose flag
 *
 * @note    defined in main.c
 */
extern int verbose;



//////// Implementation according instructions in savannah.gnu.org/lwip

static void low_level_init(struct netif *netif);
static struct pbuf *low_level_input(struct netif *netif);

#if !LWIP_ARP
static err_t low_level_output_arp_off(struct netif *netif, struct pbuf *q, const ip4_addr_t *ipaddr);
#endif /* LWIP_ARP */


#if LWIP_NETIF_LINK_CALLBACK
void stnetif_update_config(struct netif *netif);
#endif /* LWIP_NETIF_LINK_CALLBACK */

u8_t low_level_get_link_status(void);



/////// lwIP Device Driver based on code generated bySTM32CubeMX

/*
 *    Components of device driver
 *    ---------------------------
 *
 *    Conforming the skeleton ethernetif.c, these functions must be provided:
 *
 *    * myif_init:        Calls low_level_init() function and initializes the
 *                        netif structure.
 *
 *    * myif_input:       Calls low_level_input() function to read a packet from
 *                        the MAC hardware and passes it to the lwIP input
 *                        function.
  *
 *    * myif_output:      Writes one packet to the MAC hardware.
 *
 *    * low_level_init:   Initializes the MAC hardware.
 *
 *    * low_level_input:  Reads one packet from the MAC hardware.
 *
 *
 *     @note low_level_* handle hardware and myif_* the netif structure.
 *
 *     @note netif->state should point to a struct stnetif static variable
 */

/**
 * @brief   low_level_input
 *
 * @note    It is called when a packet is ready to be read from the interface.
 *          It uses the function low_level_input()
 *
 * @note    There is a skeleton implementation of this function in the
 *          ethernetif.c.
 *
 * @note    Allocate a pbuf and transfer the bytes of the incoming
 *          packet from the interface into the pbuf.
 *
 * @param   netif the lwip network interface structure for this ethernetif
 *
 * @return  a pbuf filled with the received packet (including MAC header)
 *          NULL on memory error
 */
static struct pbuf *
low_level_input(struct netif *netif) {
struct pbuf *p,*q;
ETH_DMAFrameInfo RxFrameInfo;
ETH_DMADescriptor *desc;
int segcount;
err_t rc;
int len;
uint16_t framelength;
uint16_t bytecnt;
uint8_t *src;
uint16_t srcpos;
uint16_t dstcnt;
uint16_t dstpos;
uint8_t *dst;
        
    MESSAGE("low_level_input\n");

    rc = ETH_ReceiveFrame(&RxFrameInfo);
    if( rc <= 0 ) return NULL;

    segcount = RxFrameInfo.SegmentCount;
    framelength = RxFrameInfo.FrameLength;
 
    MESSAGEV("Received a frame with %d segment(s) and %d byte(s)\n",
        segcount,
        framelength);

    if( framelength == 0 ) {
        p = NULL;
        goto error;
    }

    // Allocate a chain of pbuf large enough to accommodate data
    p = pbuf_alloc(PBUF_RAW,framelength,PBUF_POOL);
    if( p == NULL) {
#if LWIP_STATS
        LINK_STATS_INC(link.memerr);
        LINK_STATS_INC(link.drop);
        MIB2_STATS_NETIF_INC(netif, ifindiscards);
#endif
        goto error;
    }

#if ETH_PAD_SIZE
    pbuf_remove_header(p, ETH_PAD_SIZE); /* drop the padding word */
#endif

    // scan all pbufs and get their contents from the DMA buffers
    desc = RxFrameInfo.FirstSegmentDesc;
    bytecnt = 0;                           // bytes transferred
    src = (uint8_t *) desc->Buffer1Addr;   // first DMA buffer;
    srcpos = 0;                            // offset at source


    // scan all pbufs and transfer their contents to DMA buffers
    for(q=p; q ; q = q->next ) {
        MESSAGEV("Processing %p\n",q);
        if( desc->Status&ETH_DMADESCRIPTOR_STATUS_OWN ) {
            rc = ERR_USE;
            goto error;
        }
        MESSAGEV("Transfering %d bytes from %p to %p\n",q->len,src,q->payload);
        // get source information
        dstcnt = q->len;
        dstpos = 0;
        dst = q->payload;
        int srccnt = ETH_TXBUFFER_SIZE - srcpos;
        while( srccnt < dstcnt ) {
            MESSAGEV("Copying %d bytes from %p+%1d to %p+%1d\n",
                    srccnt,src,srcpos,dst,dstpos);
            memcpy(dst + dstpos, src + srcpos, srccnt );
            bytecnt += srccnt;
            dstcnt -= srccnt;
            dstpos += srccnt;
            // Get next DMA buffer
            desc = (ETH_DMADescriptor *) desc->Buffer2NextDescAddr;
            if( desc->Status&ETH_DMADESCRIPTOR_STATUS_OWN ) {
                rc = ERR_USE;
                goto error;
            }
            src = (uint8_t *) desc->Buffer1Addr;
            srcpos = 0;
            srccnt = ETH_TXBUFFER_SIZE - srcpos;
        }
        // copy remaining data
        if( dstcnt > 0 ) {
            MESSAGEV("Copying remaining %d bytes from %p+%1d to %p+%1d\n",
                            dstcnt,src,srcpos,dst,dstpos);
            memcpy(dst + dstpos, src + srcpos, dstcnt );
            bytecnt += dstcnt;
            srcpos += dstcnt;
            dstcnt = 0;
            MESSAGE("Done\n");
        }
    }
    MESSAGEV("Transferred %d bytes of frame with %d bytes\n",bytecnt,framelength);
 
#if LWIP_STATS
    LINK_STATS_INC(link.recv);
#endif

error:
    // Set OWN bit in all descriptors part of the frame received,
    // so DMA can reuse them now
    desc = RxFrameInfo.FirstSegmentDesc;
    for(int i=0;i<RxFrameInfo.SegmentCount;i++) {
        MESSAGEV("Enabling RX descriptor at %p\n",desc);
        desc->Status |= ETH_DMADESCRIPTOR_STATUS_OWN;
        desc = (ETH_DMADescriptor *) desc->Buffer2NextDescAddr;
    }

    // Clear RxFrameInfo to avoid risk of using this data
    RxFrameInfo.FirstSegmentDesc = 0;
    RxFrameInfo.LastSegmentDesc  = 0;
    RxFrameInfo.FrameLength      = 0;
    RxFrameInfo.SegmentCount     = 0;
    // Clear flag and resume reception
    if( ETH->DMASR&ETH_DMASR_RBUS ) {
        ETH->DMASR = ETH_DMASR_RBUS;
        ETH->DMARPDR = 0;
    }

    return p;
}

#if !LWIP_ARP
/**
 * @brief   low_level_output_arp_off
 *
 */
static err_t low_level_output_arp_off(struct netif *netif, struct pbuf *q, const ip4_addr_t *ipaddr) {

    // To be implemented

    return ERR_VAL;
}
#endif /* LWIP_ARP */


/**
 * @brief   low_level_init
 *
 * @note    handles hardware initialization
 */

static void low_level_init(struct netif *netif) {

    MESSAGE("Entering low_level_init\n");

    // Initialize device
    ETH_Init();

    // Set link status
    // netif->flags |= NETIF_FLAG_LINK_UP;

    // Check link status
    //(void) low_level_get_link_status();

    // Start device
    ETH_Start();

    // Set flags accordingly
    stnetif_link(netif);

    MESSAGE("Exiting low_level_init\n");
}


///// netif level functions

/**
 * @brief stnetif_output
 *
 * @note  Called by user to transmit data
 */


/**
 * @brief  low_level_output
 *
 * This function do the actual transmission of the packet.
 *
 * @param   netif the lwip network interface structure for this ethernetif
 * @param   p the MAC packet to send (e.g. IP packet including MAC addresses and type)
 * @return  ERR_OK if the packet could be sent
 *          an err_t value if the packet couldn't be sent
 *
 * @note    The packet is contained in the pbuf that is passed to the function. This pbuf
 *          might be chained.
 * @note    Returning ERR_MEM here if a DMA queue of your MAC is full can lead to
 *          strange results. You might consider waiting for space in the DMA queue
 *          to become available since the stack doesn't retry to send a packet
 *          dropped because of memory failure (except for the TCP timers).
 */

err_t
stnetif_output(struct netif *netif, struct pbuf *p) {
struct pbuf *q;
ETH_DMADescriptor *desc;
err_t rc;

    MESSAGE("Entering stnet output\n");

#if MIB2_STATS
    LINK_STATS_INC(link.xmit);
    /* Update SNMP stats (only if you use SNMP) */
    MIB2_STATS_NETIF_ADD(netif, ifoutoctets, p->tot_len);
    int unicast = ((p->payload[0] & 0x01) == 0);
    if (unicast) {
        MIB2_STATS_NETIF_INC(netif, ifoutucastpkts);
    } else {
        MIB2_STATS_NETIF_INC(netif, ifoutnucastpkts);
    }
#endif

    lock_interrupts();

#if ETH_PAD_SIZE
    pbuf_remove_header(p, ETH_PAD_SIZE); /* drop the padding word */
#endif

    /*
     * Copy data from all pbufs to one or more DMA buffers
     * concatenating them
     */
    desc = ETH_TXDescriptors;                   // first DMA descriptor
    uint16_t framelength = 0;                   // frame size
    uint8_t *dst = (uint8_t *)desc->Buffer1Addr;// first DMA buffer;
    uint16_t dstpos = 0;                        // offset
    // scan all pbufs and transfer their contents to DMA buffers
    for(q=p; q && desc; q = q->next ) {
        message("Processing pbuf at %p\n",q);
        if( desc->Status&ETH_DMADESCRIPTOR_STATUS_OWN ) {
            MESSAGE("Descriptor not free\n");
            rc = ERR_USE;
            goto error;
        }
        message("Free descriptor found at %p\n",desc);
        // get source information
        uint16_t srccnt = q->len;
        uint16_t srcpos = 0;
        uint8_t *src = q->payload;
        int dstcnt = ETH_TXBUFFER_SIZE - dstpos;
        // Transfer to DMA buffers
        while( dstcnt < srccnt ) {
            memcpy(dst + dstpos, src + srcpos, dstcnt );
            message("%d bytes copied (1)\n",dstcnt);
            framelength += dstcnt;
            srccnt -= dstcnt;
            srcpos += dstcnt;
            // Get next DMA buffer
            desc = (ETH_DMADescriptor *) desc->Buffer2NextDescAddr;
            if( desc == ETH_TXDescriptors )
                break;
            if( (desc->Status&ETH_DMADESCRIPTOR_STATUS_OWN) ) {
                rc = ERR_USE;
                goto error;
            }
            dst = (uint8_t *) desc->Buffer1Addr;
            dstpos = 0;
            dstcnt = ETH_TXBUFFER_SIZE - dstpos;
        }
        // copy remaining data
        if( desc ) {
            memcpy(dst + dstpos, src + srcpos, srccnt );
            message("%d bytes copied (2)\n",dstcnt);
            framelength += srccnt;
            dstpos += srccnt;
        }
    }

    MESSAGE("Starting transmission\n");
    /* Start MAC transmit here */
    ETH_TransmitFrame(ETH_TXDescriptors, framelength);

#if MIB2_STATS
    MIB2_STATS_NETIF_ADD(netif, ifoutoctets, p->tot_len);

    if (((u8_t *)p->payload)[0] & 1) {
        /* broadcast or multicast packet*/
        MIB2_STATS_NETIF_INC(netif, ifoutnucastpkts);
    } else {
        /* unicast packet */
        MIB2_STATS_NETIF_INC(netif, ifoutucastpkts);
    }
#endif

    /* increase ifoutdiscards or ifouterrors on error */
#if ETH_PAD_SIZE
    pbuf_add_header(p, ETH_PAD_SIZE); /* reclaim the padding word */
#endif

#if LWIP_STATS
    LINK_STATS_INC(link.xmit);
#endif

    unlock_interrupts();
    rc = ERR_OK;

    // An error occurred
error:
    MESSAGE("Exiting stnet_output\n");
    return rc;
}

/**
 * @brief stnetif_input
 *
 * @note  Called in the main loop
 *
 */

void
stnetif_input(struct netif *netif) {
//struct stnetif *stnetif;
struct pbuf *p;

    MESSAGE("Entering stnet input\n");

    //stnetif = netif->state;

    /* move received packet into a new pbuf */
    p = low_level_input(netif);
    /* if no packet could be read, silently ignore this */
    if (p != NULL) {
        MESSAGE("Passing to ethernet_input\n");
        /* pass all packets to ethernet_input, which decides what packets it supports */
        if (netif->input(p, netif) != ERR_OK) {
          LWIP_DEBUGF(NETIF_DEBUG, ("ethernetif_input: IP input error\n"));
          pbuf_free(p);
          p = NULL;
        }
    }

    MESSAGE("Exiting stnet input\n");

}


/**
 * @brief   stnetif_init
 *
 * @note    Called by lwip to initialize device
 */
/**
 * @brief   ethernet_init
 *
 * @note    Called at the beginning of the program to set up the
 *          network interface. It calls the function low_level_init() to do the
 *          actual setup of the hardware.
 *
 * @note    This function should be passed as a parameter to netif_add()!!!!!!
 *
 * @param   netif the lwip network interface structure for this ethernetif
 *
 * @return  ERR_OK if the netif is initialized
 *          ERR_MEM if private data couldn't be allocated
 *          any other err_t on error
 */

err_t
stnetif_init(struct netif *netif) {
uint8_t macaddr[6];

    MESSAGE("Entering netif_init\n");

#if LWIP_NETIF_HOSTNAME
    /* Initialize interface hostname */
    netif->hostname = "lwip";
#endif /* LWIP_NETIF_HOSTNAME */

#if LWIP_SNMP
    /* ifType ethernetCsmacd(6) @see RFC1213 (snmp_mib2.h)*/
    netif->link_type = 6;
    /* Estimated speed */
    netif->link_speed = 100000000;
    netif->ts = 0;
    netif->ifinoctets = 0;
    netif->ifinucastpkts = 0;
    netif->ifinnucastpkts = 0;
    netif->ifindiscards = 0;
    netif->ifoutoctets = 0;
    netif->ifoutucastpkts = 0;
    netif->ifoutnucastpkts = 0;
    netif->ifoutdiscards = 0;
#endif  /* LWIP_SNMP */

    netif->name[0] = IFNAME0;
    netif->name[1] = IFNAME1;

    netif->linkoutput = stnetif_output; // Or low_level_output?
#if LWIP_IPV4
    netif->output = etharp_output;
#endif /* LWIP_IPV4 */
#if LWIP_IPV6
    netif->output_ip6 = ethip6_output;
#endif /* LWIP_IPV6 */

    netif->mtu        =   ETH_MTU;
    netif->flags      =   NETIF_FLAG_BROADCAST
                        | NETIF_FLAG_ETHARP
                        | NETIF_FLAG_ETHERNET
                        | NETIF_FLAG_IGMP;

    ETH_GetMACAddressAsVector(macaddr);
    SMEMCPY(netif->hwaddr, macaddr, ETH_HWADDR_LEN);
    netif->hwaddr_len = ETH_HWADDR_LEN;

 #if LWIP_IPV6 && LWIP_IPV6_MLD
    /*
     * For hardware/netifs that implement MAC filtering.
    .*/
    if (netif->mld_mac_filter != NULL) {
        ip6_addr_t ip6_allnodes_ll;
        ip6_addr_set_allnodes_linklocal(&ip6_allnodes_ll);
        netif->mld_mac_filter(netif, &ip6_allnodes_ll, NETIF_ADD_MAC_FILTER);
    }
#endif /* LWIP_IPV6 && LWIP_IPV6_MLD */

    etharp_cleanup_netif(netif);

    // Do hardware initialization
    low_level_init(netif);

    // Set link status
    netif->flags |= NETIF_FLAG_LINK_UP;

    // Check link status
    (void) low_level_get_link_status();

    MESSAGE("Exiting netif_init\n");

    return ERR_OK;

}

/*
 *    Link status
 *    -----------
 *
 *    For ethernet, there are the link status problem. The ethernet cable
 *    can be plugged out or the switch went offline.
 *
 *    There are two possibilities. One using the interrupt generated by th
 *    PHY interface device. Another is to poll the device.
 *
 *    lwIP has a set of functions/macros to handle this situation.
 *
 *          * netif_is_up:          macro returns 1 of UP flag is set,
 *                                  otherwise 0. This flag set set means that
 *                                  the interface is enabled and can handle
 *                                  traffic
 *          * netif_set_up:         function
 *          * netif_set_down:       function
 *          * netif_is_link_up:     macro returns 1 of LINK_UP flag is set,
 *                                  otherwise 0. When set, the link should be
 *                                  active.
 *          * netif_set_link_up:    function sets flag LINK_UP
 *          * netif_set_link_down:  function
 *
 * @note    The *netif_set_link_up* and *netif_set_link_down* function must be
 *          used when the  LWIP_NETIF_LINK_CALLBACK compilation flag is set.
 *          When not set, the flag netif->flags could be set directly.
 *
 * @note    lwIP raw API has a set of callback related to the
 *          netif structure.
 *
 *          *status_callback: is called when the netif state changed
 *          *link_callback:   is called when the netif link is changed.
 *          *remove_callback: is called when the interface is beeing removed
 *
 *          The callback function prototype is
 *          void function(struct netif *)
 *
 *          They are set by the functions
 *          netif_set_{link,remove,status}_callback
 *
 *          These functionalities are enable by defining the following
 *          parameters in the lwipopts.h header file.
 *
 *          LWIP_NETIF_STATUS_CALLBACK
 *          LWIP_NETIF_LINK_CALLBACK
 *          LWIP_NETIF_REMOVE_CALLBACK
 *
 *
 * @note    There is an extended set of callbacks. They have the prototype
 *          void function(  struct netif *,
 *                          netif_nsc_reason_t,
 *                          netif_ext_callback_args_t *)
 *          They are set thru a call to
 *          netif_add_ext_callback( netif_ext_callback_t *,
 *                                  function)
 *          They can be removed by calling
 *          netif_remove_ext_callback(function)
 *
 *          The reasons already defined (more can be added in future) are:
 *
 *          LWIP_NSC_NONE                     initialization
 *          LWIP_NSC_NETIF_ADDED              netif was added
 *          LWIP_NSC_NETIF_REMOVED            netif was removed
 *          LWIP_NSC_LINK_CHANGED             link changed
 *          LWIP_NSC_STATUS_CHANGED           netif administrative status changed
 *          LWIP_NSC_IPV4_ADDRESS_CHANGED     IPv4 address has changed
 *          LWIP_NSC_IPV4_GATEWAY_CHANGED     IPv4 gateway has changed
 *          LWIP_NSC_IPV4_NETMASK_CHANGED     IPv4 netmask has changed
 *          LWIP_NSC_IPV4_SETTINGS_CHANGED    IPv4 address/gateway/netmask changed
 *          LWIP_NSC_IPV6_SET                 IPv6 address was added
 *          LWIP_NSC_IPV6_ADDR_STATE_CHANGED  IPv6 address state has changed
 *
 */



/**
 * @brief   low_level_get_link_status
 *
 * @note    returns 1 if link is up (connected). Otherwise returns 0.
 */

u8_t low_level_get_link_status(void) {

    ETH_UpdateLinkStatus();
    return ETH_IsLinkUp();

}

/**
 * @brief   Print link status
 *
 */
#define PRINTPHYSTATUS(M,DESC) printf("%-30s  : %s\n",(DESC),((M)!=0)?"ON":"OFF")

void stnetif_printstatus(void) {
#if 0
uint32_t s;

    s = ETH_GetLinkStatus();

    // BSR
    PRINTPHYSTATUS(s&0x4000,"100BASET Full Duplex");
    PRINTPHYSTATUS(s&0x2000,"100BASET Half Duplex");
    PRINTPHYSTATUS(s&0x1000,"10BASET Full Duplex");
    PRINTPHYSTATUS(s&0x0800,"10BASET Half Duplex");
    PRINTPHYSTATUS(s&0x0100,"Extended Status");
    PRINTPHYSTATUS(s&0x0020,"Auto Negotiation Completed");
    PRINTPHYSTATUS(s&0x0008,"Auto Negotiation Ability");
    PRINTPHYSTATUS(s&0x0004,"Link Status");
    PRINTPHYSTATUS(s&0x0002,"Jabber Detect");
    PRINTPHYSTATUS(s&0x0001,"Extended Capabilities");
    s >>= 16;

    // BCR
    PRINTPHYSTATUS(s&0x8000,"Soft Reset");
    PRINTPHYSTATUS(s&0x4000,"Loopback");
    PRINTPHYSTATUS(s&0x2000,"Speed Select");
    PRINTPHYSTATUS(s&0x1000,"Auto Negotiation Enable");
    PRINTPHYSTATUS(s&0x0800,"Power Down");
    PRINTPHYSTATUS(s&0x0400,"Isolate");
    PRINTPHYSTATUS(s&0x0200,"Restart Auto Negotiation");
    PRINTPHYSTATUS(s&0x0100,"Duplex Mode");
#endif

    message("Link status = %s\n",ETH_GetLinkInfoString());

}


/**
 * @brief   stnetif_link
 *
 * @note    check link status
 */
void stnetif_link(struct netif *netif) {
u8_t up;

    MESSAGE("stnet link\n");

    up = low_level_get_link_status();

    if( up ) {
        MESSAGE("Link is up\n");
    } else {
        MESSAGE("Link is down\n");
    }

    if( up&&!netif_is_link_up(netif) ) {
        // If link is up but netif state is link_down
        // set link up in netif
        netif_set_link_up(netif);
    } else if( !up&&netif_is_link_up(netif) ) {
        // If link is down but netif state is link_up
        // set link down in netif
        netif_set_link_down(netif);
    }

    up = netif_is_link_up(netif);
    message("Link is %s <----\n",up?"UP":"DOWN");

    int i;
    ip4_addr_t *ipaddr;
    struct netif *pnetif;
    struct eth_addr *ethaddr;
    char s[20];
    u64_t n;
    u8_t *pn;

    for(i=0;i<ARP_TABLE_SIZE;i++) {
        etharp_get_entry(i,&ipaddr,&pnetif,&ethaddr);
        ipaddr_ntoa_r(ipaddr,s,20);
        pn = ethaddr->addr;
        n = (((u64_t) pn[5])<<40)
           |(((u64_t) pn[4])<<32)
           |(((u64_t) pn[3])<<24)
           |(((u64_t) pn[2])<<16)
           |(((u64_t) pn[1])<<8)
           |(((u64_t) pn[0])<<0);
        printf(" %d %s %p %06lX\n",
                i,
                s,
                netif,
                n
                );
    }
}


#if LWIP_NETIF_LINK_CALLBACK
/**
  * @brief  This function should called on a change of link status
  *         to update low level driver configuration.
  *
  * @param  netif: The network interface
  *
  * @retval None
  */
void stnetif_update_config(struct netif *netif) {

    if( netif_is_link_up(netif) ) {
        // Update configuration (Speed/Duplex)
        ETH_UpdateLinkStatus();

        /* Restart MAC interface */
        ETH_Start();
    } else {
        /* Stop MAC interface */
        ETH_Stop();
    }
}
#endif

/**
 * @brief stnetif_status_callback
 *
 * @note  Called every time the status (up,down) of network connection changes
 */
void stnetif_status_callback(struct netif *netif) {

    message("netif status changed %s\n", ip4addr_ntoa(netif_ip4_addr(netif)));

}


#if LWIP_NETIF_LINK_CALLBACK
/**
 * @brief stnetif_link_callback
 *
 * @note  Called every time the status (up,down) of network connection changes
 */
void stnetif_link_callback(struct netif *netif) {

    message("netif link status changed %s\n", ip4addr_ntoa(netif_ip4_addr(netif)));
    stnetif_update_config(netif);

}
#endif

